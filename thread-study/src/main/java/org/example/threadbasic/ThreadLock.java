package org.example.threadbasic;

/**
 * @ClassName ThreadLock
 * @Description
 *乐观锁与悲观锁
 *  悲观锁：数据被外界修改持保守态度，认为线程很容易被其他线程修改，所以在数据被处理前先对数据进行加锁，
 *  在整个数据处理过程中，使数据处于锁定状态。悲观锁的实现往往依靠数据库提供的锁机制，即在数据库中，在对数据记录操作前给记录加排他锁
 *  乐观锁：认为数据在一般情况下不会造成冲突，所以访问记录前不会加排它锁，而是在进行数据提交更新时，才会正式对数据冲突与否进行检测。
 *公平锁与非公平锁
 *  公平锁表示线程获取锁的顺序使按照线程请求锁的时间早晚来决定的，也就是最早请求锁的线程将最早获取到锁。
 *  而非公平锁则在运行时闯入，也就是先来不一定先得。
 *  ReentrantLock提供了公平和非公平锁的实现：
 *  - 公平锁：ReentrantLock pairLock = new ReentrantLock(true)
 *  - 非公平锁：ReentrantLock pairLock = new ReentrantLock(false)。如果构造函数不传递参数，则默认是非公平锁。
 *  在没有公平性需求的前提下尽量使用非公平锁，因为公平锁会带来性能开销
 *独占锁和共享锁：根据锁只能被单个线程持有还是能被多个线程共同持有，可以分为独占锁和共享锁
 *  独占锁保证任何时候都只有一个线程能得到锁，ReentrantLock就是以独占方式实现的。共享锁则可以同时由多个线程持有，例如ReadWriteLock读写锁，
 *  它允许一个资源可以被多线程同时进行操作。
 *  独占锁是一种悲观锁，由于每次访问资源都先加上互斥锁，这限制了并发性
 *可重入锁
 *  当一个线程要获取一个被其他线程持有的独占锁时，该线程会被阻塞，那么当一个线程再次获取他自己已经获取的锁时是否会被阻塞？
 *  如果不被阻塞，那么我们说该锁是可重入的，也就是只要该线程获取了该锁，那么可以无限次数（严格来说是有限次数）地进入该锁锁住地代码
 *自旋锁
 *  由于JAVA中的线程是与操作系统的线程一一对应的，所以当一个线程在获取锁失败后，会被切换到内核状态而被挂起，
 *  当该线程获取到锁时又需要切换到内核状态而唤醒该线程。而从用户状态切换到内核状态的开销是比较大的，在一定程度上会影响到并发性能。
 *  自旋锁则是，当前线程在获取锁时，如果发现锁已经被其他线程占有，他不会马上阻塞自己，而在不放弃CPU使用权的情况下多次尝试获取
 *  （默认次数是10，可以使用-XX:PreBlockSpinsh参数设置该值）
 *  这很有可能让CPU时间被白白浪费
 * @Author yoveuio
 * @Date 2020/6/13 12:06
 * @Version 1.0
 */
public class ThreadLock {



}
